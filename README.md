# Casely

## 개요
사내 업무용 사이트(원본 사이트 xxx.xxxxx.com)의 업무 데이터(cases)를 추출해서 보여주는 **지극히 개인적인 용도**의 프로젝트. 역할에 따라 크게 3가지 파트로 구성된다.
1. **브라우저 확장(크롬 익스텐션)** - 원본 사이트의 로컬스토리지에 저장된 액세스토큰을 추출해서 로컬 서버로 전송.
2. **로컬 서버(python)** - 넘겨받은 액세스토큰으로 원본 사이트에서 데이터 폴링. 변경 감지. DB에 저장. 리액트앱에서 쓸 API 제공.
3. **리액트앱** - 나한테 편한 방법으로 표시.

---

## 왜?
원본 사이트가 너무너무너무 불편해서 혈압 오르고, 변경 내역을 자주 놓쳐서 옆자리 Elsa한테 까이는 일이 많다.
- 각 아이템(업무 case)들은 각자 고유의 히스토리(검토, 파일 업로드, 승인, 반려, 완료, 대화,...)를 가지고 있는데 목록 페이지에서 이 이력들을 확인하기가 불가능하다. 결국 매번 하나하나 눌러 들어가서 살펴봐야 하는데 그 상세 페이지 또한 불편하기 그지 없고 불안정함.
- 최근 변경 아이템 순 정렬... 그런 지극히 필요한 기능이 없음.
- 특정 카테고리만 보고 싶은데 카테고리로 필터링해주는 기능이 반쪽 자리. 다중 카테고리 선택이 안되서 결국 두번 필터링해서 두번 확인해야 함.
- 심지어 목록 페이지에서는 카테고리가 표시가 되었다 말았다 해서 표시가 안되는 경우 다시 1페이지로 돌아가야 다시 표시가 된다.
- 상세 페이지에서는 대화 내역을 api호출로 받아오는데 그 과정에 피드백(로딩,로딩완료,...)이 전혀 없다. 대화 내역이 원래 비어있는 건지 로딩이 안된건지 새로고침 한번 눌러봐야 하는지...
- 기타 등등.

---

## 어떻게?
### 브라우저 확장
- 원본 사이트의 로컬스토리지에 저장된 액세스토큰과 유저id를 뽑아옴. 근래에는 액세스토큰을 이렇게 쉽게 접근할 수 있는 곳에 노출시키는 건 완전 비권장 분위기인데 사내 웹사이트여서인지, 너무 오래 전에 만든 사이트여서인지, 혹은 별 관심이 없어서인지 그냥 노출되어 있음. 너무 고맙지.
- 브라우저 확장도 다른 사이트의 로컬 스토리지에 직접 접근을 할 수는 없음. 원본 사이트에 접속 시에 원본 사이트 스크립트에 내가 만든 스크립트를 살짝 끼워넣어야 함. 해당 스크립트가 주기적으로 로컬스토리지에서 액세스토큰을 꺼내서 브라우저 확장으로 보내고 브라우저 확장이 내 로컬 서버로 보내줌.
### 로컬 서버    
- 액세스토큰이 있더라도 그걸 사용해서 원본 사이트의 API에 접근하는 건 어렵다. 사실 원본 사이트는 잘 응답해주지만 CORS 정책 때문에 브라우저가 결과를 나한테 주지 않고 폐기처분해버림. 브라우저 확장에서 보내는 요청에 대해서는 이걸 우회하지만 그냥 파이썬을 사용하기로 함.
- 사실 이 프로젝트 이전에는 파이썬을 써본 적이 없다. 메모장과 작별을 해보고자 사내망을 *검은바위 나락*™ 뒤지 듯 샅샅히 뒤진 결과(IT 관련부서가 몇개인지도 모를 정도로 많기 때문에 분명 어딘가에 vscode가 있을 것 같았음) 우연히 발견함. 하지만 인터넷이 안되니까 추가모듈 같은 건 설치가 불가능하고 순수 파이썬 기본 모듈들만 사용해야 함.
- 파이썬 서버(기본 모듈만으로 간단하게 서버를 열 수 있다!!)는 브라우저 확장에서 넘겨받은 액세스토큰을 사용해서 원본 서버의 데이터를 폴링하고 sqlite db에 저장(파이썬 기본 모듈에 들어있다!). 저장 시 이전 저장값과 다른 경우 타임스탬프 업데이트. 리액트앱의 요청에 따라 저장된 데이터 반환.
### 리액트앱
- 로컬 서버의 모든 데이터를 로드해서 redux나 zustand 스토어에 모두 보관. => zustand로 결정함.
- 주기적으로 로컬 서버에 데이터 요청을 보내되 since 값을 같이 보내서 해당 시간 이후에 업데이트된 아이템들만 새로 받아옴.
- 새로 받아온 데이터로 즉시 store에 반영...을 할까 하다가 변경이 있다는 표시만 해주고 내가 원하는 시점에 반영되게 하는 쪽으로 방향을 바꿈. 이렇게 해야 내가 변경 내역을 놓치지 않을 것 같다...
- 브라우저 indexed db에 데이터 스냅샷을 저장하고 앱이 로드될 때에는 이 데이터를 로드함. 그리고 로컬 서버로부터 그 이후의 변경 내용 수신. => 이렇게 하면 칼퇴근 이후에 일어난 일들도 추적할 수 있다. 다음날 아침 새로 업데이트된 상태로 시작할 것이 아니라 전날 저녁 6시까지의 상태로 시작하고 그 이후의 변경 내용을 확인할 수 있단 말씀.
- 스냅샷은 최신의 스냅샷만 저장할 게 아니라 지속적으로 스냅샷을 누적시키면(물론 오래된 것들은 하루에 한개씩만 남기고 삭제하는 방식으로 어느정도 정리 필요) 무엇이 언제 바뀌었는지 맘대로 되감기를 할 수 있는 **타임머신 기능**이 가능함. redux나 zustand로 이런 기능 구현은 너무 쉽다.

---

## 개발?
- mock서버. 개발 시에 원본 사이트를 흉내내줌. `npm run dev:mock`
- python 로컬 서버. 백엔드. 프로젝트 루트에서 `python3 -m server.server`. 회사에서는 아마 `python3`가 아니라 `py`였던 걸로...(기억 안나서 py, python, python3를 한번씩 쳐봐야 함)
- 리액트앱. `npm run dev:app`

---

## 회사로 옮기는 법
- 옮겨야 할 것들: 빌드된(ts => js) 브라우저 확장, server 폴더, 빌드된 리액트앱.
- 리액트앱 용량이 살벌할 듯?
    - 집에서: 빌드 => zip => base64 인코드(1500줄 씩 분리) => 사내 메일로 전송
    - 회사에서: 분리된 base64 텍스트를 하나로 합쳐서 저장 => base64 디코드 => unzip

---

## 원본 사이트... 흠좀무...
- 원본 사이트의 API가 반환하는 JSON에는 여러개의 날짜 타입이 있다. `YYYY/MM/DD`, `YYYY/MM/DD HH/MM`, 그리고 ISO포맷. 왜 그래야만 했을까..? 몇 바이트 아껴서 살림살이가 얼마나 나아진다고 `시간:분`까지만 주는건지? 1분 동안에 일어날 수 일들은 많다. 실제로 원본 사이트에서도 같은 '분'에 해당하는 아이템들의 정렬이 이 때문에 꼬인다.
- 목록 요청과 상세 요청에서 돌려주는 값의 데이터가 다르다. 목록 요청에는 문자열을 돌려주고 상세 요청에는 숫자를 문자인척 "2","3"으로 돌려준다. 왜 굳이?(뭐 목록 요청에 대한 결과는 아무 처리없이 바로 페이지에 보여줄 수 있는 값을 넣어서 보내준다는 걸로 이해하려 하지만...)
- 심지어 필드 이름도 목록 요청과 상세 요청에서 달라진다. `viewCode` vs `viewcode`
- 납득이 안되는 필드 이름들... `isSecurity`?
- 비슷한 데이터 타입들이 여러개가 있는데 속성 이름들이 다들 제각각...
- `fileId`가 여기서는 1234(number), 다른데서는 "1234"(string).
- 필드값 `GRATER`? 이게 뭘까 한참을 고민했는데 해당 필드의 다른 값들이 `LESS`, `EQUAL`인 걸로 보아... 그렇다. 아마도 `GREATER`를 의도했겠지! 사실 이 필드가 어디에 쓰이는지까지 파고 든다면 `LESS`, `EQUAL`도 떳떳하진 못함.
